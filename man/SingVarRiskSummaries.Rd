% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ComputeMixtureSummaries.R
\name{SingVarRiskSummaries}
\alias{SingVarRiskSummaries}
\title{Single Variable Risk Summaries}
\usage{
SingVarRiskSummaries(
  fit,
  y = NULL,
  Z = NULL,
  X = NULL,
  modifier = NULL,
  which.z = 1:ncol(Z),
  qs.diff = c(0.25, 0.75),
  q.fixed = c(0.25, 0.5, 0.75),
  m.fixed = NULL,
  method = "fullpost",
  sel = NULL,
  z.names = colnames(Z),
  ...
)
}
\arguments{
\item{fit}{An object containing the results returned by a the \code{kmbayes} function}

\item{y}{a vector of outcome data of length \code{n}.}

\item{Z}{an \code{n}-by-\code{M} matrix of predictor variables to be included in the \code{h} function. Each row represents an observation and each column represents an predictor.}

\item{X}{an \code{n}-by-\code{K} matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.}

\item{modifier}{a vector categorical values of length \code{n} that may modify the exposure-response associations. Control level ordering by using class \code{factor}, or use default level orders with any vector class.}

\item{which.z}{vector indicating which variables (columns of \code{Z}) for which the summary should be computed}

\item{qs.diff}{vector indicating the two quantiles \code{q_1} and \code{q_2} at which to compute \code{h(z_{q2}) - h(z_{q1})}}

\item{q.fixed}{vector of quantiles at which to fix the remaining predictors in \code{Z}}

\item{m.fixed}{the modifier value at which to compare the estimated \code{h} function}

\item{method}{method for obtaining posterior summaries at a vector of new points. Options are "approx" and "exact"; defaults to "approx", which is faster particularly for large datasets; see details. Only "exact" is supported now}

\item{sel}{logical expression indicating samples to keep; defaults to keeping the second half of all samples}

\item{z.names}{optional vector of names for the columns of \code{z}}

\item{...}{other arguments to pass on to the prediction function}
}
\value{
a data frame containing the (posterior mean) estimate and posterior standard deviation of the single-predictor risk measures
}
\description{
Compute summaries of the risks associated with a change in a single variable in \code{Z} from a single level (quantile) to a second level (quantile), for the other variables in \code{Z} fixed to a specific level (quantile) for a given modifier level
}
\details{
\itemize{
  \item If \code{method == "approx"}, the argument \code{sel} defaults to the second half of the MCMC iterations.
  \item If \code{method == "exact"}, the argument \code{sel} defaults to keeping every 10 iterations after dropping the first 50\% of samples, or if this results in fewer than 100 iterations, than 100 iterations are kept
}
For guided examples and additional information, see vignette(bkmrGSOverview)
}
\examples{
## First generate data set
y <- ex_data$y
Z <- ex_data$Z
modifier <- ex_data$X$Sex
X_full <- ex_data$X[,-2] #remove Sex from the covariate matrix because it is the modifier
X <- model.matrix(~., data=X_full)[,-1] #create design matrix to account for factor variables, remove the intercept column

## Fit model 
## Using only 10 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm <- kmbayes(y = y, Z = Z, modifier = modifier, X = X, iter = 10, verbose = FALSE) 

risks.singvar <- SingVarRiskSummaries(fitkm, qs.diff = c(0.25, 0.75), q.fixed = 0.5, m.fixed = "male", method = "exact")
}
